{"ast":null,"code":"import { Util } from 'leaflet';\nimport featureLayerService from '../../Services/FeatureLayerService';\nimport { getUrlParams, warn, setEsriAttribution } from '../../Util';\nimport { FeatureGrid } from './FeatureGrid';\nimport BinarySearchIndex from 'tiny-binary-search';\nexport var FeatureManager = FeatureGrid.extend({\n  /**\r\n   * Options\r\n   */\n  options: {\n    attribution: null,\n    where: '1=1',\n    fields: ['*'],\n    from: false,\n    to: false,\n    timeField: false,\n    timeFilterMode: 'server',\n    simplifyFactor: 0,\n    precision: 6\n  },\n\n  /**\r\n   * Constructor\r\n   */\n  initialize: function (options) {\n    FeatureGrid.prototype.initialize.call(this, options);\n    options = getUrlParams(options);\n    options = Util.setOptions(this, options);\n    this.service = featureLayerService(options);\n    this.service.addEventParent(this); // use case insensitive regex to look for common fieldnames used for indexing\n\n    if (this.options.fields[0] !== '*') {\n      var oidCheck = false;\n\n      for (var i = 0; i < this.options.fields.length; i++) {\n        if (this.options.fields[i].match(/^(OBJECTID|FID|OID|ID)$/i)) {\n          oidCheck = true;\n        }\n      }\n\n      if (oidCheck === false) {\n        warn('no known esriFieldTypeOID field detected in fields Array.  Please add an attribute field containing unique IDs to ensure the layer can be drawn correctly.');\n      }\n    }\n\n    if (this.options.timeField.start && this.options.timeField.end) {\n      this._startTimeIndex = new BinarySearchIndex();\n      this._endTimeIndex = new BinarySearchIndex();\n    } else if (this.options.timeField) {\n      this._timeIndex = new BinarySearchIndex();\n    }\n\n    this._cache = {};\n    this._currentSnapshot = []; // cache of what layers should be active\n\n    this._activeRequests = 0;\n  },\n\n  /**\r\n   * Layer Interface\r\n   */\n  onAdd: function (map) {\n    // include 'Powered by Esri' in map attribution\n    setEsriAttribution(map);\n    this.service.metadata(function (err, metadata) {\n      if (!err) {\n        var supportedFormats = metadata.supportedQueryFormats; // Check if someone has requested that we don't use geoJSON, even if it's available\n\n        var forceJsonFormat = false;\n\n        if (this.service.options.isModern === false) {\n          forceJsonFormat = true;\n        } // Unless we've been told otherwise, check to see whether service can emit GeoJSON natively\n\n\n        if (!forceJsonFormat && supportedFormats && supportedFormats.indexOf('geoJSON') !== -1) {\n          this.service.options.isModern = true;\n        }\n\n        if (metadata.objectIdField) {\n          this.service.options.idAttribute = metadata.objectIdField;\n        } // add copyright text listed in service metadata\n\n\n        if (!this.options.attribution && map.attributionControl && metadata.copyrightText) {\n          this.options.attribution = metadata.copyrightText;\n          map.attributionControl.addAttribution(this.getAttribution());\n        }\n      }\n    }, this);\n    map.on('zoomend', this._handleZoomChange, this);\n    return FeatureGrid.prototype.onAdd.call(this, map);\n  },\n  onRemove: function (map) {\n    map.off('zoomend', this._handleZoomChange, this);\n    return FeatureGrid.prototype.onRemove.call(this, map);\n  },\n  getAttribution: function () {\n    return this.options.attribution;\n  },\n\n  /**\r\n   * Feature Management\r\n   */\n  createCell: function (bounds, coords) {\n    // dont fetch features outside the scale range defined for the layer\n    if (this._visibleZoom()) {\n      this._requestFeatures(bounds, coords);\n    }\n  },\n  _requestFeatures: function (bounds, coords, callback) {\n    this._activeRequests++; // our first active request fires loading\n\n    if (this._activeRequests === 1) {\n      this.fire('loading', {\n        bounds: bounds\n      }, true);\n    }\n\n    return this._buildQuery(bounds).run(function (error, featureCollection, response) {\n      if (response && response.exceededTransferLimit) {\n        this.fire('drawlimitexceeded');\n      } // no error, features\n\n\n      if (!error && featureCollection && featureCollection.features.length) {\n        // schedule adding features until the next animation frame\n        Util.requestAnimFrame(Util.bind(function () {\n          this._addFeatures(featureCollection.features, coords);\n\n          this._postProcessFeatures(bounds);\n        }, this));\n      } // no error, no features\n\n\n      if (!error && featureCollection && !featureCollection.features.length) {\n        this._postProcessFeatures(bounds);\n      }\n\n      if (error) {\n        this._postProcessFeatures(bounds);\n      }\n\n      if (callback) {\n        callback.call(this, error, featureCollection);\n      }\n    }, this);\n  },\n  _postProcessFeatures: function (bounds) {\n    // deincrement the request counter now that we have processed features\n    this._activeRequests--; // if there are no more active requests fire a load event for this view\n\n    if (this._activeRequests <= 0) {\n      this.fire('load', {\n        bounds: bounds\n      });\n    }\n  },\n  _cacheKey: function (coords) {\n    return coords.z + ':' + coords.x + ':' + coords.y;\n  },\n  _addFeatures: function (features, coords) {\n    var key = this._cacheKey(coords);\n\n    this._cache[key] = this._cache[key] || [];\n\n    for (var i = features.length - 1; i >= 0; i--) {\n      var id = features[i].id;\n\n      if (this._currentSnapshot.indexOf(id) === -1) {\n        this._currentSnapshot.push(id);\n      }\n\n      if (this._cache[key].indexOf(id) === -1) {\n        this._cache[key].push(id);\n      }\n    }\n\n    if (this.options.timeField) {\n      this._buildTimeIndexes(features);\n    }\n\n    this.createLayers(features);\n  },\n  _buildQuery: function (bounds) {\n    var query = this.service.query().intersects(bounds).where(this.options.where).fields(this.options.fields).precision(this.options.precision);\n    query.params['resultType'] = 'tile';\n\n    if (this.options.requestParams) {\n      Util.extend(query.params, this.options.requestParams);\n    }\n\n    if (this.options.simplifyFactor) {\n      query.simplify(this._map, this.options.simplifyFactor);\n    }\n\n    if (this.options.timeFilterMode === 'server' && this.options.from && this.options.to) {\n      query.between(this.options.from, this.options.to);\n    }\n\n    return query;\n  },\n\n  /**\r\n   * Where Methods\r\n   */\n  setWhere: function (where, callback, context) {\n    this.options.where = where && where.length ? where : '1=1';\n    var oldSnapshot = [];\n    var newSnapshot = [];\n    var pendingRequests = 0;\n    var requestError = null;\n    var requestCallback = Util.bind(function (error, featureCollection) {\n      if (error) {\n        requestError = error;\n      }\n\n      if (featureCollection) {\n        for (var i = featureCollection.features.length - 1; i >= 0; i--) {\n          newSnapshot.push(featureCollection.features[i].id);\n        }\n      }\n\n      pendingRequests--;\n\n      if (pendingRequests <= 0 && this._visibleZoom()) {\n        this._currentSnapshot = newSnapshot; // schedule adding features for the next animation frame\n\n        Util.requestAnimFrame(Util.bind(function () {\n          this.removeLayers(oldSnapshot);\n          this.addLayers(newSnapshot);\n\n          if (callback) {\n            callback.call(context, requestError);\n          }\n        }, this));\n      }\n    }, this);\n\n    for (var i = this._currentSnapshot.length - 1; i >= 0; i--) {\n      oldSnapshot.push(this._currentSnapshot[i]);\n    }\n\n    for (var key in this._cells) {\n      pendingRequests++;\n\n      var coords = this._keyToCellCoords(key);\n\n      var bounds = this._cellCoordsToBounds(coords);\n\n      this._requestFeatures(bounds, key, requestCallback);\n    }\n\n    return this;\n  },\n  getWhere: function () {\n    return this.options.where;\n  },\n\n  /**\r\n   * Time Range Methods\r\n   */\n  getTimeRange: function () {\n    return [this.options.from, this.options.to];\n  },\n  setTimeRange: function (from, to, callback, context) {\n    var oldFrom = this.options.from;\n    var oldTo = this.options.to;\n    var pendingRequests = 0;\n    var requestError = null;\n    var requestCallback = Util.bind(function (error) {\n      if (error) {\n        requestError = error;\n      }\n\n      this._filterExistingFeatures(oldFrom, oldTo, from, to);\n\n      pendingRequests--;\n\n      if (callback && pendingRequests <= 0) {\n        callback.call(context, requestError);\n      }\n    }, this);\n    this.options.from = from;\n    this.options.to = to;\n\n    this._filterExistingFeatures(oldFrom, oldTo, from, to);\n\n    if (this.options.timeFilterMode === 'server') {\n      for (var key in this._cells) {\n        pendingRequests++;\n\n        var coords = this._keyToCellCoords(key);\n\n        var bounds = this._cellCoordsToBounds(coords);\n\n        this._requestFeatures(bounds, key, requestCallback);\n      }\n    }\n\n    return this;\n  },\n  refresh: function () {\n    for (var key in this._cells) {\n      var coords = this._keyToCellCoords(key);\n\n      var bounds = this._cellCoordsToBounds(coords);\n\n      this._requestFeatures(bounds, key);\n    }\n\n    if (this.redraw) {\n      this.once('load', function () {\n        this.eachFeature(function (layer) {\n          this._redraw(layer.feature.id);\n        }, this);\n      }, this);\n    }\n  },\n  _filterExistingFeatures: function (oldFrom, oldTo, newFrom, newTo) {\n    var layersToRemove = oldFrom && oldTo ? this._getFeaturesInTimeRange(oldFrom, oldTo) : this._currentSnapshot;\n\n    var layersToAdd = this._getFeaturesInTimeRange(newFrom, newTo);\n\n    if (layersToAdd.indexOf) {\n      for (var i = 0; i < layersToAdd.length; i++) {\n        var shouldRemoveLayer = layersToRemove.indexOf(layersToAdd[i]);\n\n        if (shouldRemoveLayer >= 0) {\n          layersToRemove.splice(shouldRemoveLayer, 1);\n        }\n      }\n    } // schedule adding features until the next animation frame\n\n\n    Util.requestAnimFrame(Util.bind(function () {\n      this.removeLayers(layersToRemove);\n      this.addLayers(layersToAdd);\n    }, this));\n  },\n  _getFeaturesInTimeRange: function (start, end) {\n    var ids = [];\n    var search;\n\n    if (this.options.timeField.start && this.options.timeField.end) {\n      var startTimes = this._startTimeIndex.between(start, end);\n\n      var endTimes = this._endTimeIndex.between(start, end);\n\n      search = startTimes.concat(endTimes);\n    } else if (this._timeIndex) {\n      search = this._timeIndex.between(start, end);\n    } else {\n      warn('You must set timeField in the layer constructor in order to manipulate the start and end time filter.');\n      return [];\n    }\n\n    for (var i = search.length - 1; i >= 0; i--) {\n      ids.push(search[i].id);\n    }\n\n    return ids;\n  },\n  _buildTimeIndexes: function (geojson) {\n    var i;\n    var feature;\n\n    if (this.options.timeField.start && this.options.timeField.end) {\n      var startTimeEntries = [];\n      var endTimeEntries = [];\n\n      for (i = geojson.length - 1; i >= 0; i--) {\n        feature = geojson[i];\n        startTimeEntries.push({\n          id: feature.id,\n          value: new Date(feature.properties[this.options.timeField.start])\n        });\n        endTimeEntries.push({\n          id: feature.id,\n          value: new Date(feature.properties[this.options.timeField.end])\n        });\n      }\n\n      this._startTimeIndex.bulkAdd(startTimeEntries);\n\n      this._endTimeIndex.bulkAdd(endTimeEntries);\n    } else {\n      var timeEntries = [];\n\n      for (i = geojson.length - 1; i >= 0; i--) {\n        feature = geojson[i];\n        timeEntries.push({\n          id: feature.id,\n          value: new Date(feature.properties[this.options.timeField])\n        });\n      }\n\n      this._timeIndex.bulkAdd(timeEntries);\n    }\n  },\n  _featureWithinTimeRange: function (feature) {\n    if (!this.options.from || !this.options.to) {\n      return true;\n    }\n\n    var from = +this.options.from.valueOf();\n    var to = +this.options.to.valueOf();\n\n    if (typeof this.options.timeField === 'string') {\n      var date = +feature.properties[this.options.timeField];\n      return date >= from && date <= to;\n    }\n\n    if (this.options.timeField.start && this.options.timeField.end) {\n      var startDate = +feature.properties[this.options.timeField.start];\n      var endDate = +feature.properties[this.options.timeField.end];\n      return startDate >= from && startDate <= to || endDate >= from && endDate <= to || startDate <= from && endDate >= to;\n    }\n  },\n  _visibleZoom: function () {\n    // check to see whether the current zoom level of the map is within the optional limit defined for the FeatureLayer\n    if (!this._map) {\n      return false;\n    }\n\n    var zoom = this._map.getZoom();\n\n    if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {\n      return false;\n    } else {\n      return true;\n    }\n  },\n  _handleZoomChange: function () {\n    if (!this._visibleZoom()) {\n      this.removeLayers(this._currentSnapshot);\n      this._currentSnapshot = [];\n    } else {\n      /*\r\n      for every cell in this._cells\r\n        1. Get the cache key for the coords of the cell\r\n        2. If this._cache[key] exists it will be an array of feature IDs.\r\n        3. Call this.addLayers(this._cache[key]) to instruct the feature layer to add the layers back.\r\n      */\n      for (var i in this._cells) {\n        var coords = this._cells[i].coords;\n\n        var key = this._cacheKey(coords);\n\n        if (this._cache[key]) {\n          this.addLayers(this._cache[key]);\n        }\n      }\n    }\n  },\n\n  /**\r\n   * Service Methods\r\n   */\n  authenticate: function (token) {\n    this.service.authenticate(token);\n    return this;\n  },\n  metadata: function (callback, context) {\n    this.service.metadata(callback, context);\n    return this;\n  },\n  query: function () {\n    return this.service.query();\n  },\n  _getMetadata: function (callback) {\n    if (this._metadata) {\n      var error;\n      callback(error, this._metadata);\n    } else {\n      this.metadata(Util.bind(function (error, response) {\n        this._metadata = response;\n        callback(error, this._metadata);\n      }, this));\n    }\n  },\n  addFeature: function (feature, callback, context) {\n    this.addFeatures(feature, callback, context);\n  },\n  addFeatures: function (features, callback, context) {\n    this._getMetadata(Util.bind(function (error, metadata) {\n      if (error) {\n        if (callback) {\n          callback.call(this, error, null);\n        }\n\n        return;\n      } // GeoJSON featureCollection or simple feature\n\n\n      var featuresArray = features.features ? features.features : [features];\n      this.service.addFeatures(features, Util.bind(function (error, response) {\n        if (!error) {\n          for (var i = featuresArray.length - 1; i >= 0; i--) {\n            // assign ID from result to appropriate objectid field from service metadata\n            featuresArray[i].properties[metadata.objectIdField] = featuresArray.length > 1 ? response[i].objectId : response.objectId; // we also need to update the geojson id for createLayers() to function\n\n            featuresArray[i].id = featuresArray.length > 1 ? response[i].objectId : response.objectId;\n          }\n\n          this.createLayers(featuresArray);\n        }\n\n        if (callback) {\n          callback.call(context, error, response);\n        }\n      }, this));\n    }, this));\n  },\n  updateFeature: function (feature, callback, context) {\n    this.updateFeatures(feature, callback, context);\n  },\n  updateFeatures: function (features, callback, context) {\n    // GeoJSON featureCollection or simple feature\n    var featuresArray = features.features ? features.features : [features];\n    this.service.updateFeatures(features, function (error, response) {\n      if (!error) {\n        for (var i = featuresArray.length - 1; i >= 0; i--) {\n          this.removeLayers([featuresArray[i].id], true);\n        }\n\n        this.createLayers(featuresArray);\n      }\n\n      if (callback) {\n        callback.call(context, error, response);\n      }\n    }, this);\n  },\n  deleteFeature: function (id, callback, context) {\n    this.deleteFeatures(id, callback, context);\n  },\n  deleteFeatures: function (ids, callback, context) {\n    return this.service.deleteFeatures(ids, function (error, response) {\n      var responseArray = response.length ? response : [response];\n\n      if (!error && responseArray.length > 0) {\n        for (var i = responseArray.length - 1; i >= 0; i--) {\n          this.removeLayers([responseArray[i].objectId], true);\n        }\n      }\n\n      if (callback) {\n        callback.call(context, error, response);\n      }\n    }, this);\n  }\n});","map":{"version":3,"sources":["C:/Users/incluit/Desktop/projects/smartHuerta-FE/egghead-code-examples/add-placename-location-search-to-react-leaflet-esri-leaflet-geocoder/node_modules/esri-leaflet/src/Layers/FeatureLayer/FeatureManager.js"],"names":["Util","featureLayerService","getUrlParams","warn","setEsriAttribution","FeatureGrid","BinarySearchIndex","FeatureManager","extend","options","attribution","where","fields","from","to","timeField","timeFilterMode","simplifyFactor","precision","initialize","prototype","call","setOptions","service","addEventParent","oidCheck","i","length","match","start","end","_startTimeIndex","_endTimeIndex","_timeIndex","_cache","_currentSnapshot","_activeRequests","onAdd","map","metadata","err","supportedFormats","supportedQueryFormats","forceJsonFormat","isModern","indexOf","objectIdField","idAttribute","attributionControl","copyrightText","addAttribution","getAttribution","on","_handleZoomChange","onRemove","off","createCell","bounds","coords","_visibleZoom","_requestFeatures","callback","fire","_buildQuery","run","error","featureCollection","response","exceededTransferLimit","features","requestAnimFrame","bind","_addFeatures","_postProcessFeatures","_cacheKey","z","x","y","key","id","push","_buildTimeIndexes","createLayers","query","intersects","params","requestParams","simplify","_map","between","setWhere","context","oldSnapshot","newSnapshot","pendingRequests","requestError","requestCallback","removeLayers","addLayers","_cells","_keyToCellCoords","_cellCoordsToBounds","getWhere","getTimeRange","setTimeRange","oldFrom","oldTo","_filterExistingFeatures","refresh","redraw","once","eachFeature","layer","_redraw","feature","newFrom","newTo","layersToRemove","_getFeaturesInTimeRange","layersToAdd","shouldRemoveLayer","splice","ids","search","startTimes","endTimes","concat","geojson","startTimeEntries","endTimeEntries","value","Date","properties","bulkAdd","timeEntries","_featureWithinTimeRange","valueOf","date","startDate","endDate","zoom","getZoom","maxZoom","minZoom","authenticate","token","_getMetadata","_metadata","addFeature","addFeatures","featuresArray","objectId","updateFeature","updateFeatures","deleteFeature","deleteFeatures","responseArray"],"mappings":"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","sourcesContent":["import { Util } from 'leaflet';\r\nimport featureLayerService from '../../Services/FeatureLayerService';\r\nimport { getUrlParams, warn, setEsriAttribution } from '../../Util';\r\nimport { FeatureGrid } from './FeatureGrid';\r\nimport BinarySearchIndex from 'tiny-binary-search';\r\n\r\nexport var FeatureManager = FeatureGrid.extend({\r\n  /**\r\n   * Options\r\n   */\r\n\r\n  options: {\r\n    attribution: null,\r\n    where: '1=1',\r\n    fields: ['*'],\r\n    from: false,\r\n    to: false,\r\n    timeField: false,\r\n    timeFilterMode: 'server',\r\n    simplifyFactor: 0,\r\n    precision: 6\r\n  },\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n\r\n  initialize: function (options) {\r\n    FeatureGrid.prototype.initialize.call(this, options);\r\n\r\n    options = getUrlParams(options);\r\n    options = Util.setOptions(this, options);\r\n\r\n    this.service = featureLayerService(options);\r\n    this.service.addEventParent(this);\r\n\r\n    // use case insensitive regex to look for common fieldnames used for indexing\r\n    if (this.options.fields[0] !== '*') {\r\n      var oidCheck = false;\r\n      for (var i = 0; i < this.options.fields.length; i++) {\r\n        if (this.options.fields[i].match(/^(OBJECTID|FID|OID|ID)$/i)) {\r\n          oidCheck = true;\r\n        }\r\n      }\r\n      if (oidCheck === false) {\r\n        warn(\r\n          'no known esriFieldTypeOID field detected in fields Array.  Please add an attribute field containing unique IDs to ensure the layer can be drawn correctly.'\r\n        );\r\n      }\r\n    }\r\n\r\n    if (this.options.timeField.start && this.options.timeField.end) {\r\n      this._startTimeIndex = new BinarySearchIndex();\r\n      this._endTimeIndex = new BinarySearchIndex();\r\n    } else if (this.options.timeField) {\r\n      this._timeIndex = new BinarySearchIndex();\r\n    }\r\n\r\n    this._cache = {};\r\n    this._currentSnapshot = []; // cache of what layers should be active\r\n    this._activeRequests = 0;\r\n  },\r\n\r\n  /**\r\n   * Layer Interface\r\n   */\r\n\r\n  onAdd: function (map) {\r\n    // include 'Powered by Esri' in map attribution\r\n    setEsriAttribution(map);\r\n\r\n    this.service.metadata(function (err, metadata) {\r\n      if (!err) {\r\n        var supportedFormats = metadata.supportedQueryFormats;\r\n\r\n        // Check if someone has requested that we don't use geoJSON, even if it's available\r\n        var forceJsonFormat = false;\r\n        if (this.service.options.isModern === false) {\r\n          forceJsonFormat = true;\r\n        }\r\n\r\n        // Unless we've been told otherwise, check to see whether service can emit GeoJSON natively\r\n        if (\r\n          !forceJsonFormat &&\r\n          supportedFormats &&\r\n          supportedFormats.indexOf('geoJSON') !== -1\r\n        ) {\r\n          this.service.options.isModern = true;\r\n        }\r\n\r\n        if (metadata.objectIdField) {\r\n          this.service.options.idAttribute = metadata.objectIdField;\r\n        }\r\n\r\n        // add copyright text listed in service metadata\r\n        if (\r\n          !this.options.attribution &&\r\n          map.attributionControl &&\r\n          metadata.copyrightText\r\n        ) {\r\n          this.options.attribution = metadata.copyrightText;\r\n          map.attributionControl.addAttribution(this.getAttribution());\r\n        }\r\n      }\r\n    }, this);\r\n\r\n    map.on('zoomend', this._handleZoomChange, this);\r\n\r\n    return FeatureGrid.prototype.onAdd.call(this, map);\r\n  },\r\n\r\n  onRemove: function (map) {\r\n    map.off('zoomend', this._handleZoomChange, this);\r\n\r\n    return FeatureGrid.prototype.onRemove.call(this, map);\r\n  },\r\n\r\n  getAttribution: function () {\r\n    return this.options.attribution;\r\n  },\r\n\r\n  /**\r\n   * Feature Management\r\n   */\r\n\r\n  createCell: function (bounds, coords) {\r\n    // dont fetch features outside the scale range defined for the layer\r\n    if (this._visibleZoom()) {\r\n      this._requestFeatures(bounds, coords);\r\n    }\r\n  },\r\n\r\n  _requestFeatures: function (bounds, coords, callback) {\r\n    this._activeRequests++;\r\n\r\n    // our first active request fires loading\r\n    if (this._activeRequests === 1) {\r\n      this.fire(\r\n        'loading',\r\n        {\r\n          bounds: bounds\r\n        },\r\n        true\r\n      );\r\n    }\r\n\r\n    return this._buildQuery(bounds).run(function (\r\n      error,\r\n      featureCollection,\r\n      response\r\n    ) {\r\n      if (response && response.exceededTransferLimit) {\r\n        this.fire('drawlimitexceeded');\r\n      }\r\n\r\n      // no error, features\r\n      if (!error && featureCollection && featureCollection.features.length) {\r\n        // schedule adding features until the next animation frame\r\n        Util.requestAnimFrame(\r\n          Util.bind(function () {\r\n            this._addFeatures(featureCollection.features, coords);\r\n            this._postProcessFeatures(bounds);\r\n          }, this)\r\n        );\r\n      }\r\n\r\n      // no error, no features\r\n      if (!error && featureCollection && !featureCollection.features.length) {\r\n        this._postProcessFeatures(bounds);\r\n      }\r\n\r\n      if (error) {\r\n        this._postProcessFeatures(bounds);\r\n      }\r\n\r\n      if (callback) {\r\n        callback.call(this, error, featureCollection);\r\n      }\r\n    },\r\n    this);\r\n  },\r\n\r\n  _postProcessFeatures: function (bounds) {\r\n    // deincrement the request counter now that we have processed features\r\n    this._activeRequests--;\r\n\r\n    // if there are no more active requests fire a load event for this view\r\n    if (this._activeRequests <= 0) {\r\n      this.fire('load', {\r\n        bounds: bounds\r\n      });\r\n    }\r\n  },\r\n\r\n  _cacheKey: function (coords) {\r\n    return coords.z + ':' + coords.x + ':' + coords.y;\r\n  },\r\n\r\n  _addFeatures: function (features, coords) {\r\n    var key = this._cacheKey(coords);\r\n    this._cache[key] = this._cache[key] || [];\r\n\r\n    for (var i = features.length - 1; i >= 0; i--) {\r\n      var id = features[i].id;\r\n\r\n      if (this._currentSnapshot.indexOf(id) === -1) {\r\n        this._currentSnapshot.push(id);\r\n      }\r\n      if (this._cache[key].indexOf(id) === -1) {\r\n        this._cache[key].push(id);\r\n      }\r\n    }\r\n\r\n    if (this.options.timeField) {\r\n      this._buildTimeIndexes(features);\r\n    }\r\n\r\n    this.createLayers(features);\r\n  },\r\n\r\n  _buildQuery: function (bounds) {\r\n    var query = this.service\r\n      .query()\r\n      .intersects(bounds)\r\n      .where(this.options.where)\r\n      .fields(this.options.fields)\r\n      .precision(this.options.precision);\r\n\r\n    query.params['resultType'] = 'tile';\r\n\r\n    if (this.options.requestParams) {\r\n      Util.extend(query.params, this.options.requestParams);\r\n    }\r\n\r\n    if (this.options.simplifyFactor) {\r\n      query.simplify(this._map, this.options.simplifyFactor);\r\n    }\r\n\r\n    if (\r\n      this.options.timeFilterMode === 'server' &&\r\n      this.options.from &&\r\n      this.options.to\r\n    ) {\r\n      query.between(this.options.from, this.options.to);\r\n    }\r\n\r\n    return query;\r\n  },\r\n\r\n  /**\r\n   * Where Methods\r\n   */\r\n\r\n  setWhere: function (where, callback, context) {\r\n    this.options.where = where && where.length ? where : '1=1';\r\n\r\n    var oldSnapshot = [];\r\n    var newSnapshot = [];\r\n    var pendingRequests = 0;\r\n    var requestError = null;\r\n    var requestCallback = Util.bind(function (error, featureCollection) {\r\n      if (error) {\r\n        requestError = error;\r\n      }\r\n\r\n      if (featureCollection) {\r\n        for (var i = featureCollection.features.length - 1; i >= 0; i--) {\r\n          newSnapshot.push(featureCollection.features[i].id);\r\n        }\r\n      }\r\n\r\n      pendingRequests--;\r\n\r\n      if (pendingRequests <= 0 && this._visibleZoom()) {\r\n        this._currentSnapshot = newSnapshot;\r\n        // schedule adding features for the next animation frame\r\n        Util.requestAnimFrame(\r\n          Util.bind(function () {\r\n            this.removeLayers(oldSnapshot);\r\n            this.addLayers(newSnapshot);\r\n            if (callback) {\r\n              callback.call(context, requestError);\r\n            }\r\n          }, this)\r\n        );\r\n      }\r\n    }, this);\r\n\r\n    for (var i = this._currentSnapshot.length - 1; i >= 0; i--) {\r\n      oldSnapshot.push(this._currentSnapshot[i]);\r\n    }\r\n    for (var key in this._cells) {\r\n      pendingRequests++;\r\n      var coords = this._keyToCellCoords(key);\r\n      var bounds = this._cellCoordsToBounds(coords);\r\n      this._requestFeatures(bounds, key, requestCallback);\r\n    }\r\n\r\n    return this;\r\n  },\r\n\r\n  getWhere: function () {\r\n    return this.options.where;\r\n  },\r\n\r\n  /**\r\n   * Time Range Methods\r\n   */\r\n\r\n  getTimeRange: function () {\r\n    return [this.options.from, this.options.to];\r\n  },\r\n\r\n  setTimeRange: function (from, to, callback, context) {\r\n    var oldFrom = this.options.from;\r\n    var oldTo = this.options.to;\r\n    var pendingRequests = 0;\r\n    var requestError = null;\r\n    var requestCallback = Util.bind(function (error) {\r\n      if (error) {\r\n        requestError = error;\r\n      }\r\n      this._filterExistingFeatures(oldFrom, oldTo, from, to);\r\n\r\n      pendingRequests--;\r\n\r\n      if (callback && pendingRequests <= 0) {\r\n        callback.call(context, requestError);\r\n      }\r\n    }, this);\r\n\r\n    this.options.from = from;\r\n    this.options.to = to;\r\n\r\n    this._filterExistingFeatures(oldFrom, oldTo, from, to);\r\n\r\n    if (this.options.timeFilterMode === 'server') {\r\n      for (var key in this._cells) {\r\n        pendingRequests++;\r\n        var coords = this._keyToCellCoords(key);\r\n        var bounds = this._cellCoordsToBounds(coords);\r\n        this._requestFeatures(bounds, key, requestCallback);\r\n      }\r\n    }\r\n\r\n    return this;\r\n  },\r\n\r\n  refresh: function () {\r\n    for (var key in this._cells) {\r\n      var coords = this._keyToCellCoords(key);\r\n      var bounds = this._cellCoordsToBounds(coords);\r\n      this._requestFeatures(bounds, key);\r\n    }\r\n\r\n    if (this.redraw) {\r\n      this.once(\r\n        'load',\r\n        function () {\r\n          this.eachFeature(function (layer) {\r\n            this._redraw(layer.feature.id);\r\n          }, this);\r\n        },\r\n        this\r\n      );\r\n    }\r\n  },\r\n\r\n  _filterExistingFeatures: function (oldFrom, oldTo, newFrom, newTo) {\r\n    var layersToRemove =\r\n      oldFrom && oldTo\r\n        ? this._getFeaturesInTimeRange(oldFrom, oldTo)\r\n        : this._currentSnapshot;\r\n    var layersToAdd = this._getFeaturesInTimeRange(newFrom, newTo);\r\n\r\n    if (layersToAdd.indexOf) {\r\n      for (var i = 0; i < layersToAdd.length; i++) {\r\n        var shouldRemoveLayer = layersToRemove.indexOf(layersToAdd[i]);\r\n        if (shouldRemoveLayer >= 0) {\r\n          layersToRemove.splice(shouldRemoveLayer, 1);\r\n        }\r\n      }\r\n    }\r\n\r\n    // schedule adding features until the next animation frame\r\n    Util.requestAnimFrame(\r\n      Util.bind(function () {\r\n        this.removeLayers(layersToRemove);\r\n        this.addLayers(layersToAdd);\r\n      }, this)\r\n    );\r\n  },\r\n\r\n  _getFeaturesInTimeRange: function (start, end) {\r\n    var ids = [];\r\n    var search;\r\n\r\n    if (this.options.timeField.start && this.options.timeField.end) {\r\n      var startTimes = this._startTimeIndex.between(start, end);\r\n      var endTimes = this._endTimeIndex.between(start, end);\r\n      search = startTimes.concat(endTimes);\r\n    } else if (this._timeIndex) {\r\n      search = this._timeIndex.between(start, end);\r\n    } else {\r\n      warn(\r\n        'You must set timeField in the layer constructor in order to manipulate the start and end time filter.'\r\n      );\r\n      return [];\r\n    }\r\n\r\n    for (var i = search.length - 1; i >= 0; i--) {\r\n      ids.push(search[i].id);\r\n    }\r\n\r\n    return ids;\r\n  },\r\n\r\n  _buildTimeIndexes: function (geojson) {\r\n    var i;\r\n    var feature;\r\n    if (this.options.timeField.start && this.options.timeField.end) {\r\n      var startTimeEntries = [];\r\n      var endTimeEntries = [];\r\n      for (i = geojson.length - 1; i >= 0; i--) {\r\n        feature = geojson[i];\r\n        startTimeEntries.push({\r\n          id: feature.id,\r\n          value: new Date(feature.properties[this.options.timeField.start])\r\n        });\r\n        endTimeEntries.push({\r\n          id: feature.id,\r\n          value: new Date(feature.properties[this.options.timeField.end])\r\n        });\r\n      }\r\n      this._startTimeIndex.bulkAdd(startTimeEntries);\r\n      this._endTimeIndex.bulkAdd(endTimeEntries);\r\n    } else {\r\n      var timeEntries = [];\r\n      for (i = geojson.length - 1; i >= 0; i--) {\r\n        feature = geojson[i];\r\n        timeEntries.push({\r\n          id: feature.id,\r\n          value: new Date(feature.properties[this.options.timeField])\r\n        });\r\n      }\r\n\r\n      this._timeIndex.bulkAdd(timeEntries);\r\n    }\r\n  },\r\n\r\n  _featureWithinTimeRange: function (feature) {\r\n    if (!this.options.from || !this.options.to) {\r\n      return true;\r\n    }\r\n\r\n    var from = +this.options.from.valueOf();\r\n    var to = +this.options.to.valueOf();\r\n\r\n    if (typeof this.options.timeField === 'string') {\r\n      var date = +feature.properties[this.options.timeField];\r\n      return date >= from && date <= to;\r\n    }\r\n\r\n    if (this.options.timeField.start && this.options.timeField.end) {\r\n      var startDate = +feature.properties[this.options.timeField.start];\r\n      var endDate = +feature.properties[this.options.timeField.end];\r\n      return (\r\n        (startDate >= from && startDate <= to) ||\r\n        (endDate >= from && endDate <= to) ||\r\n        (startDate <= from && endDate >= to)\r\n      );\r\n    }\r\n  },\r\n\r\n  _visibleZoom: function () {\r\n    // check to see whether the current zoom level of the map is within the optional limit defined for the FeatureLayer\r\n    if (!this._map) {\r\n      return false;\r\n    }\r\n    var zoom = this._map.getZoom();\r\n    if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {\r\n      return false;\r\n    } else {\r\n      return true;\r\n    }\r\n  },\r\n\r\n  _handleZoomChange: function () {\r\n    if (!this._visibleZoom()) {\r\n      this.removeLayers(this._currentSnapshot);\r\n      this._currentSnapshot = [];\r\n    } else {\r\n      /*\r\n      for every cell in this._cells\r\n        1. Get the cache key for the coords of the cell\r\n        2. If this._cache[key] exists it will be an array of feature IDs.\r\n        3. Call this.addLayers(this._cache[key]) to instruct the feature layer to add the layers back.\r\n      */\r\n      for (var i in this._cells) {\r\n        var coords = this._cells[i].coords;\r\n        var key = this._cacheKey(coords);\r\n        if (this._cache[key]) {\r\n          this.addLayers(this._cache[key]);\r\n        }\r\n      }\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Service Methods\r\n   */\r\n\r\n  authenticate: function (token) {\r\n    this.service.authenticate(token);\r\n    return this;\r\n  },\r\n\r\n  metadata: function (callback, context) {\r\n    this.service.metadata(callback, context);\r\n    return this;\r\n  },\r\n\r\n  query: function () {\r\n    return this.service.query();\r\n  },\r\n\r\n  _getMetadata: function (callback) {\r\n    if (this._metadata) {\r\n      var error;\r\n      callback(error, this._metadata);\r\n    } else {\r\n      this.metadata(\r\n        Util.bind(function (error, response) {\r\n          this._metadata = response;\r\n          callback(error, this._metadata);\r\n        }, this)\r\n      );\r\n    }\r\n  },\r\n\r\n  addFeature: function (feature, callback, context) {\r\n    this.addFeatures(feature, callback, context);\r\n  },\r\n\r\n  addFeatures: function (features, callback, context) {\r\n    this._getMetadata(\r\n      Util.bind(function (error, metadata) {\r\n        if (error) {\r\n          if (callback) {\r\n            callback.call(this, error, null);\r\n          }\r\n          return;\r\n        }\r\n        // GeoJSON featureCollection or simple feature\r\n        var featuresArray = features.features ? features.features : [features];\r\n\r\n        this.service.addFeatures(\r\n          features,\r\n          Util.bind(function (error, response) {\r\n            if (!error) {\r\n              for (var i = featuresArray.length - 1; i >= 0; i--) {\r\n                // assign ID from result to appropriate objectid field from service metadata\r\n                featuresArray[i].properties[metadata.objectIdField] =\r\n                  featuresArray.length > 1\r\n                    ? response[i].objectId\r\n                    : response.objectId;\r\n                // we also need to update the geojson id for createLayers() to function\r\n                featuresArray[i].id =\r\n                  featuresArray.length > 1\r\n                    ? response[i].objectId\r\n                    : response.objectId;\r\n              }\r\n              this.createLayers(featuresArray);\r\n            }\r\n\r\n            if (callback) {\r\n              callback.call(context, error, response);\r\n            }\r\n          }, this)\r\n        );\r\n      }, this)\r\n    );\r\n  },\r\n\r\n  updateFeature: function (feature, callback, context) {\r\n    this.updateFeatures(feature, callback, context);\r\n  },\r\n\r\n  updateFeatures: function (features, callback, context) {\r\n    // GeoJSON featureCollection or simple feature\r\n    var featuresArray = features.features ? features.features : [features];\r\n    this.service.updateFeatures(\r\n      features,\r\n      function (error, response) {\r\n        if (!error) {\r\n          for (var i = featuresArray.length - 1; i >= 0; i--) {\r\n            this.removeLayers([featuresArray[i].id], true);\r\n          }\r\n          this.createLayers(featuresArray);\r\n        }\r\n\r\n        if (callback) {\r\n          callback.call(context, error, response);\r\n        }\r\n      },\r\n      this\r\n    );\r\n  },\r\n\r\n  deleteFeature: function (id, callback, context) {\r\n    this.deleteFeatures(id, callback, context);\r\n  },\r\n\r\n  deleteFeatures: function (ids, callback, context) {\r\n    return this.service.deleteFeatures(\r\n      ids,\r\n      function (error, response) {\r\n        var responseArray = response.length ? response : [response];\r\n        if (!error && responseArray.length > 0) {\r\n          for (var i = responseArray.length - 1; i >= 0; i--) {\r\n            this.removeLayers([responseArray[i].objectId], true);\r\n          }\r\n        }\r\n        if (callback) {\r\n          callback.call(context, error, response);\r\n        }\r\n      },\r\n      this\r\n    );\r\n  }\r\n});\r\n"]},"metadata":{},"sourceType":"module"}